{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#what-is-burrito","title":"What is burrito?","text":"<p>Burrito is a TACoS (Terraform Automation Collaboration Software) Kubernetes Operator.</p> <p></p>"},{"location":"#why-burrito","title":"Why burrito?","text":"<p><code>terraform</code> is a tremendous tool to manage your infrastructure in IaC. But, it does not come up with an out-of the box solution for managing state drift.</p> <p>Also, writing a CI/CD pipeline for Terraform can be painful and depends on the tool you are using.</p> <p>Finally, currently, there is no easy way to navigate your Terraform state to truly understand the modifications it undergoes when running <code>terraform apply</code>.</p> <p><code>burrito</code> aims to tackle those issues by:</p> <ul> <li>Planning continuously your Terraform code and run applies if needed</li> <li>Offering an out of the box PR/MR integration so you do not have to write CI/CD pipelines for Terraform ever again</li> <li>Showing your state's modifications in a simple Web UI (not implemented yet)</li> </ul>"},{"location":"#getting-started","title":"Getting started","text":""},{"location":"#quick-start","title":"Quick start","text":"<pre><code>kubectl create namespace burrito\nkubectl apply -n burrito -f https://raw.githubusercontent.com/padok-team/burrito/main/manifests/install.yaml\n</code></pre> <p>Follow our getting started guide. Further user oriented documentation is provided for additional features.</p>"},{"location":"getting-started/","title":"Getting started","text":""},{"location":"getting-started/#requirements","title":"Requirements","text":"<ul> <li>Installed kubectl command-line tool.</li> <li>Have a kubeconfig file (default location is <code>~/.kube/config</code>).</li> </ul>"},{"location":"getting-started/#1-install-burrito","title":"1. Install burrito","text":"<pre><code>kubectl create namespace burrito\nkubectl apply -n burrito -f https://raw.githubusercontent.com/padok-team/burrito/main/manifests/install.yaml\n</code></pre> <p>This will create a new namespace, <code>burrito</code>, where burrito services will live.</p> <p>Warning</p> <p>The installation manifests include <code>ClusterRoleBinding</code> resources that reference <code>burrito</code> namespace. If you are installing burrito into a different namespace then make sure to update the namespace reference.</p> <p>Info</p> <p>You might be interested by our Helm chart, that provides more control over burrito's configuration as well as a multi-tenant architecture.</p>"},{"location":"getting-started/#2-create-a-connection-to-a-private-repository","title":"2. Create a connection to a private repository","text":"<p>Create a Kubernetes <code>Secret</code> which looks like:</p> <pre><code>kind: Secret\nmetadata:\n  name: burrito-repo\n  namespace: burrito\ntype: Opaque\nstringData:\n  username: &lt;my-username&gt;\n  password: &lt;my-password | my-access-token&gt;\n  sshPrivateKey: |\n    -----BEGIN OPENSSH PRIVATE KEY-----\n    ...\n    -----END OPENSSH PRIVATE KEY-----\n</code></pre> <p>Then, create a <code>TerraformRepository</code> Kubernetes resource:</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformRepository\nmetadata:\n  name: burrito\n  namespace: burrito\nspec:\n  repository:\n    url: &lt;https_or_ssh_repository_url&gt;\n    secretName: burrito-repo\n</code></pre> <p>Info</p> <p>You can also connect to a public repository by omitting <code>spec.repository.secretName</code> in your <code>TerraformLayer</code> definition.</p>"},{"location":"getting-started/#3-synchronize-a-terraform-layer","title":"3. Synchronize a terraform layer","text":"<p>After creating a <code>TerraformRepository</code> you can create a <code>TerraformLayer</code> ressource which looks like:</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\n  name: random-pets\n  namespace: burrito\nspec:\n  terraform:\n    version: \"1.3.1\"\n  path: \"internal/e2e/testdata/random-pets\"\n  branch: \"main\"\n  repository:\n    name: burrito\n    namespace: burrito\n</code></pre>"},{"location":"operator-manual/","title":"Overview","text":"<p>This guide is for administrator and operator wanting to install and configure burrito for other developers.</p> <p>Note</p> <p>Please make sure you've completed the getting started guide.</p>"},{"location":"operator-manual/advanced-configuration/","title":"Advanced configuration","text":"<p>You can configure <code>burrito</code> with environment variables.</p> Environment variable Description Default <code>BURRITO_REDIS_HOSTNAME</code> the redis host to connect to <code>burrito-redis.burrito-system</code> <code>BURRITO_REDIS_SERVERPORT</code> the port of the redis to connect to <code>6379</code> <code>BURRITO_REDIS_DATABASE</code> the redis database to connect to <code>0</code> <code>BURRITO_REDIS_PASSWORD</code> the redis password (empty)"},{"location":"operator-manual/advanced-configuration/#controllers-configuration","title":"Controllers' configuration","text":"Environment variable Description Default <code>BURRITO_CONTROLLER_NAMESPACES</code> list of namespaces to watch (comma-separated) <code>burrito-system</code> <code>BURRITO_CONTROLLER_TYPES</code> list of controllers to start <code>layer,repository,run,pullrequest</code> <code>BURRITO_CONTROLLER_TIMERS_DRIFTDETECTION</code> period between two plans for drift detection <code>20m</code> <code>BURRITO_CONTROLLER_TIMERS_ONERROR</code> period between two runners launch when an error occurred in the controllers <code>1m</code> <code>BURRITO_CONTROLLER_TIMERS_WAITACTION</code> period between two runners launch when a layer is locked <code>1m</code> <code>BURRITO_CONTROLLER_TIMERS_FAILUREGRACEPERIOD</code> initial time before retry, goes exponential function of number failure <code>15s</code> <code>BURRITO_CONTROLLER_TERRAFORMMAXRETRIES</code> default number of retries for terraform runs (can be overriden in CRDs) <code>5</code> <code>BURRITO_CONTROLLER_LEADERELECTION_ENABLED</code> whether leader election is enabled or not <code>true</code> <code>BURRITO_CONTROLLER_LEADERELECTION_ID</code> lease id used for leader election <code>6d185457.terraform.padok.cloud</code> <code>BURRITO_CONTROLLER_HEALTHPROBEBINDADDRESS</code> address to bind the health probe server embedded in the controllers <code>:8081</code> <code>BURRITO_CONTROLLER_METRICSBINDADDRESS</code> address to bind the metrics server embedded in the controllers <code>:8080</code> <code>BURRITO_CONTROLLER_KUBERNETESWEBHOOKPORT</code> port used by the validating webhook server embedded in the controllers <code>9443</code>"},{"location":"operator-manual/advanced-configuration/#servers-configuration","title":"Server's configuration","text":"Environment variable Description Default <code>BURRITO_SERVER_ADDR</code> address the server listens on <code>:8080</code> <p>Info</p> <p>For webhook configuration see Setup a git webhook.</p>"},{"location":"operator-manual/advanced-configuration/#runners-configuration","title":"Runners' configuration","text":"<p>Currently, runners' configuration is not exposed.</p> <p>Info</p> <p>You can override some of the runner's pod spec. See override the runner pod spec documentation.</p>"},{"location":"operator-manual/architecture/","title":"Architectural Overview","text":""},{"location":"operator-manual/architecture/#components","title":"Components","text":""},{"location":"operator-manual/architecture/#the-server","title":"The server","text":"<p>The server is a REST server which exposes the API consumed by the Web UI. It has the following responsibilities:</p> <ul> <li>listener for Git webhook events</li> </ul> <p>Other features will be implemented when the Web UI will be in development.</p>"},{"location":"operator-manual/architecture/#the-repository-controller","title":"The repository Controller","text":"<p>The repository controller is a Kubernetes Controller which is only used to register <code>TerraformRepository</code> resources.</p>"},{"location":"operator-manual/architecture/#the-layer-controller","title":"The layer Controller","text":"<p>The layer controller is a Kubernetes Controller which continuously monitors declared <code>TerraformLayer</code> resources. It regurlarly creates <code>TerraformRun</code> resources which run a <code>terraform plan</code> for each of your layer to check if a drift has been introduced. If so, it has the possibility to create a <code>TerraformRun</code> that does a <code>terraform apply</code>.</p> <p>It is also responsible for running your Terraform <code>plan</code> and <code>apply</code> if there is a new commit on your layer.</p>"},{"location":"operator-manual/architecture/#the-run-controller","title":"The run Controller","text":"<p>The run controller is a Kubernetes Controller which continuously monitors declared <code>TerraformRun</code> resources.</p> <p>It is responsible for running the <code>terraform plan</code> and <code>terraform apply</code> commands by creating runner pods. It handles failure and retries of the runner pods.</p> <p>It also generates <code>Leases</code> to make sure no concurrent terraform commands will be launched on the same layer at the same time.</p>"},{"location":"operator-manual/architecture/#the-redis-instance","title":"The Redis instance","text":"<p>The Redis instance is used to store the binary generated by <code>terraform plan</code> before running the <code>apply</code>. We also store information about the <code>plan</code>/<code>apply</code> output to print it in the resources' statuses</p>"},{"location":"operator-manual/architecture/#implementation","title":"Implementation","text":"<p>The operator has been bootstrapped using the <code>operator-sdk</code>.</p> <p>The CLI used to start the different components is implemented using <code>cobra</code>.</p>"},{"location":"operator-manual/architecture/#the-terraformlayer-controller","title":"The TerraformLayer Controller","text":"<p>The status of a <code>TerraformLayer</code> is defined using the conditions standards defined by the community.</p> <p>3 conditions are defined for a layer:</p> <ul> <li><code>IsPlanArtifactUpToDate</code>. This condition is used for drift detection. The evaluation is made by compraing the timestamp of the last <code>terraform plan</code> which ran and the current date. The timestamp of the last plan is \"stored\" using an annotation.</li> <li><code>IsApplyUpToDate</code>. This condition is used to check if an <code>apply</code> needs to run after the last <code>plan</code>. Comparison is made by comparing a checksum of the last planned binary and a checksum last applied binary stored in the annotations.</li> <li><code>IsLastRelevantCommitPlanned</code>. This condition is used to check if a new commit has been made to the layer and need to be applied. It is evaluated by comparing the commit used for the last <code>plan</code>, the last commit which intoduced changes to the layer and the last commit made to the same branch of the repository. Those commits are \"stored\" as annotations.</li> </ul> <p>Info</p> <p>We use annotations to store information because we do not want to rely too heavily on the uptime of the Redis instance.</p> <p>With those 3 conditions, we defined 3 states:</p> <ul> <li><code>Idle</code>. This is the state of a layer if no runner needs be started</li> <li><code>PlanNeeded</code>. This is the state of a layer if burrito needs to start a <code>plan</code> runner</li> <li><code>ApplyNeeded</code>. This is the state of a layer if burrito needs to start an <code>apply</code> runner</li> </ul> <p>Info</p> <p>If you use <code>dry</code> remediation strategy and an apply is needed, the layer will stay in the <code>ApplyNeeded</code> as long as it does not need to enter the <code>PlanNeeded</code>.</p>"},{"location":"operator-manual/architecture/#the-terraformrun-controller","title":"The TerraformRun Controller","text":"<p>The status of a <code>TerraformRun</code> is also defined using the same conditions standards defined by the community.</p> <p>5 conditions are defined for a run:</p> <ul> <li><code>HasStatus</code>. This condition is used to check if a <code>TerraformRun</code> has already been reconciled by the controller.</li> <li><code>HasReachedRetryLimit</code>. Used to check if a <code>TerraformRun</code> has reached the maximum number of retries.</li> <li><code>HasSucceeded</code>. Used to check if a <code>TerraformRun</code> has already succeeded (runner pod exited successfully).</li> <li><code>IsRunning</code>. Used to check if a <code>TerraformRun</code> is currently running by checking the current phase of its associated pod.</li> <li><code>IsInfailureGracePeriod</code>. This condition is used to check if a Terraform workflow has already failed. If so, we use an exponential backoff strategy before restarting a runner on the given layer.</li> </ul> <p>With those 5 conditions, we defined 6 states:</p> <ul> <li><code>Initial</code>. This is the state of a run when it has just been created and has launched its first runner pod.</li> <li><code>Running</code>. This is the state of a run if a runner pod is currently running.</li> <li><code>FailureGracePeriod</code>. This is the state of a layer if a <code>plan</code> or <code>apply</code> runner has failed</li> <li><code>Retrying</code>. This is an intermediate state of a run if a runner pod has failed and is being restarted (not in failure grace period anymore).</li> <li><code>Succeeded</code>. This is one of the two final states a run can have. It means that the runner pod has exited successfully.</li> <li><code>Failed</code>. This is the other final state a run can have. It means that the run has failed multiple times and has reached the maximum number of retries.</li> </ul> <p>The <code>TerraformRun</code> controller also creates and deletes the Kubernetes leases to avoid concurrent use of Terraform on the same layer.</p> <p>Info</p> <p>N.B.: We use lease objects in order to not have to rely on the Redis instance for layer locking.</p>"},{"location":"operator-manual/architecture/#the-runners","title":"The runners","text":"<p>The runner image implementation heavily relies on Golang libraries provided by Hashicorp such as <code>tfexec</code> and <code>hc-install</code> which allows us to dynamically download and use any version of the Terraform binary. Thus, we support any existing version of Terraform.</p> <p>The runners also support any existing version of Terragrunt.</p> <p>The runner is responsible to update the annotations of the layer it is associated with to store information about what commit was plan/apply and when.</p>"},{"location":"operator-manual/git-webhook/","title":"Setup a Git Webhook","text":"<p>Create a webhook (with a secret!) in the repository you want to receive events from.</p> <p>Then create a secret:</p> <pre><code>kind: Secret\nmetadata:\n  name: burrito-webhook-secret\n  namespace: burrito\ntype: Opaque\nstringData:\n  burrito-webhook-secret: &lt;my-webhook-secret&gt;\n</code></pre> <p>Add the webhook secret as an environment variable of the <code>burrito-server</code>. The variables depends on your git provider.</p> Git provider Environment Variable GitHub <code>BURRITO_SERVER_WEBHOOK_GITHUB_SECRET</code> GitLab <code>BURRITO_SERVER_WEBHOOK_GITLAB_SECRET</code>"},{"location":"operator-manual/multi-tenant-architecture/","title":"Multi-tenant architecture","text":"<p>With our Helm chart we provide a way to setup multi-tenancy with burrito. This is useful when working at scale, when you controls multiple Terraform projects with burrito across several teams.</p> <p>The setup is split across multiple Kubernetes namespaces:</p> <ul> <li><code>burrito-system</code> is where burrito's components live and operate (controllers, server, Redis)</li> <li>the other namespaces (<code>tenant-namespace-[1-3]</code> on the schema) where <code>TerraformRepository</code>, <code>TerraformLayer</code>, <code>TerraformRun</code> and <code>TerraformPullRequest</code> resources live and where burrito spawns runner pods for Terraform <code>plan</code> and <code>apply</code> actions.</li> </ul> <p>Thanks to Kubernetes native RBAC system you can restrict access for your users only to the namespaces their burrito resources live.</p>"},{"location":"operator-manual/multi-tenant-architecture/#configuring-multi-tenancy-with-the-helm-chart","title":"Configuring multi-tenancy with the Helm chart","text":""},{"location":"operator-manual/multi-tenant-architecture/#1-configure-basic-tenants","title":"1. Configure basic tenants","text":"<p>In the <code>values.yaml</code> of the Helm chart, add the following:</p> <pre><code>tenants:\n  - namespace:\n      create: true\n      name: tenant-namespace-1\n    serviceAccounts:\n      - name: runner-project\n  - namespace:\n      create: true\n      name: tenant-namespace-2\n    serviceAccounts:\n      - name: runner-project\n  - namespace:\n      create: true\n      name: tenant-namespace-3\n    serviceAccounts:\n      - name: runner-project\n</code></pre> <p>This setup creates 3 tenants with 3 namespaces with one service account in each namespace.</p> <p>The chart adds every tenant referenced in its values in the namespaces that the burrito controllers must watch.</p> <p>You can also customize namespaces' labels and annotations:</p> <pre><code>tenants:\n  - namespace:\n      create: true\n      name: tenant-namespace-1\n      labels:\n        app.kubernetes.io/part-of: project-1\n      annotations:\n        helm.sh/resource-policy: keep\n</code></pre>"},{"location":"operator-manual/multi-tenant-architecture/#2-configure-service-accounts","title":"2. Configure service accounts","text":"<p>Each service account created in a tenant is binded to the <code>burrito-runner</code> ClusterRole, it is a basic role with the required permissions for a burrito runner pod to work properly.</p> <p>You can add additional role bindings to the service accounts if you need special permissions in the cluster (e.g. a Terraform layer deploying to Kubernetes) as well as annotations and labels (e.g. assume a role on a cloud provider).</p> <pre><code>  - namespace:\n      create: true\n      name: tenant-namespace-1\n    serviceAccounts:\n      - name: runner-kubernetes\n        additionalRoleBindings:\n          - name: custom\n            role:\n              kind: ClusterRole\n              name: custom-role\n      - name: runner-google\n        labels:\n          app.kubernetes.io/part-of: project-1\n        annotations:\n          iam.gke.io/gcp-service-account: burrito-project-1@company-project.iam.gserviceaccount.com\n      - name: runner-aws\n        annotations:\n          eks.amazonaws.com/role-arn: arn:aws:iam::111122223333:role/my-role\n</code></pre>"},{"location":"operator-manual/multi-tenant-architecture/#3-use-service-accounts-in-the-tenant","title":"3. Use service accounts in the tenant","text":"<p>For the <code>TerraformRepository</code> or <code>TerraformLayer</code> you deploy in a tenant, you can use the <code>overrideRunnerSpec</code> parameter to select which service account to use for runners affected to a layer/repository.</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\n  name: infra-aws\n  namespace: tenant-namespace-1\nspec:\n  terraform:\n    version: \"1.5.3\"\n  path: \"infra/layers/aws/production\"\n  branch: \"main\"\n  repository:\n    name: project-1\n    namespace: tenant-namespace-1\n  overrideRunnerSpec:\n    serviceAccountName: runner-aws # &lt;-- Specify service account here\n</code></pre>"},{"location":"operator-manual/pr-mr-workflow/","title":"PR/MR Workflow","text":"<p>Info</p> <p>In this documentation all references to pull requests can be change to merge requests for GitLab. However, the resulting Kubernetes object will still be named <code>TerraformPullRequest</code>.</p>"},{"location":"operator-manual/pr-mr-workflow/#components","title":"Components","text":""},{"location":"operator-manual/pr-mr-workflow/#the-server","title":"The server","text":"<p>Info</p> <p>For more information about the server, see the architectural overview documentation.</p> <p>Upon receiving a Pull Request creation event, the server creates a <code>TerraformPullRequest</code> resource.</p> <p>Upon receiving a Pull Request deletion event, the server deletes the related <code>TerraformPullRequest</code> resource.</p>"},{"location":"operator-manual/pr-mr-workflow/#the-pull-request-controller","title":"The pull request controller","text":"<p>The pull request controller is a Kubernetes controller which continuously monitors declared <code>TerraformPullRequest</code> resources.</p> <p>It is responsible for creating temporary <code>TerraformLayer</code> resources linked to the Pull Request it was generated from. Once all the <code>TerraformLayer</code> have planned, it will send a comment containing the plan results to the pull request.</p> <p></p>"},{"location":"operator-manual/pr-mr-workflow/#implementation","title":"Implementation","text":"<p>The status of a <code>TerraformPulLRequest</code> is defined using the conditions standards defined by the community.</p> <p>3 conditions ared defined for a pull request:</p> <ul> <li><code>IsLastCommitDiscovered</code>. This condition is used to check if we received a new commit on the pull request by comparing the latest commit on the branch and the last discovered commit.</li> <li><code>AreLayersStillPlanning</code>. This condition is used to check if all the temporary layers have finished planning. This is done by checking all the resulting <code>TerraformLayer</code> statuses.</li> <li><code>IsCommentUpToDate</code>. This condition is used to check if the controller needs to send a comment to a pull request. This is checked by comparing the last discovered commit and the last commit for which a comment was already sent.</li> </ul> <p>Info</p> <p>We use annotations to store information.</p> <p>With those 3 conditions, we defined 3 states:</p> <ul> <li><code>Idle</code>. This is the state of a pull request if nothing needs to be done.</li> <li><code>DiscoveryNeeded</code>. This is the state of a pull request if the controller needs to check which layers are affected on the given pull request.</li> <li><code>CommentNeeded</code>. This is the state of a pull request if the controller needs to send a comment to the git provider's API.</li> </ul>"},{"location":"operator-manual/pr-mr-workflow/#configuration","title":"Configuration","text":""},{"location":"operator-manual/pr-mr-workflow/#github-with-a-dedicated-github-app","title":"GitHub with a dedicated GitHub App","text":""},{"location":"operator-manual/pr-mr-workflow/#create-the-github-app","title":"Create the GitHub App","text":"<p>You can create and register GitHub Apps in your personal GitHub account or in any GitHub organization where you have administrative access.</p> <p>Follow the instructions in the GitHub documentation on Creating a GitHub App. Populate the settings as follows:</p> <ul> <li>GitHub App Name: Choose a name for your GitHub App. For example, something featuring <code>burrito</code>.</li> <li>Homepage URL: Enter https://padok-team.github.io/burrito.</li> <li>Webhook: Deselect Active. The app doesn't use this webhook events mechanism at the moment.</li> <li>Permissions: Configure the following Repository Permissions.</li> <li>Metadata: Select Read-only.</li> <li>Pull requests: Select Read &amp; write. This is required to issue comments on pull requests.</li> <li>Where can this GitHub App be installed: Select Any account.</li> </ul>"},{"location":"operator-manual/pr-mr-workflow/#creating-a-custom-badge-for-your-github-app","title":"Creating a custom badge for your GitHub App","text":"<p>You can create a custom badge for your GitHub App to display on your GitHub repository. Follow the instructions in the GitHub documentation on Creating a custom badge for your GitHub App.</p> <p>We suggest using the following one:</p> <p></p>"},{"location":"operator-manual/pr-mr-workflow/#install-the-github-app","title":"Install the GitHub App","text":"<p>Follow the instructions in the GitHub documentation on Installing your own GitHub App, and note the following:</p> <ul> <li>For Repository access, select Only select repositories, and then select the repos you want to connect with Burrito.</li> </ul>"},{"location":"operator-manual/pr-mr-workflow/#get-the-installation-id-and-app-id","title":"Get the Installation ID and App ID","text":"<p>You need the Installation ID and App ID to configure Burrito.</p> <ol> <li>Get the Installation ID from the URL of the installed app, such as:</li> </ol> <p></p> <ol> <li>Get the App ID from the app's General tab.</li> </ol> <p></p>"},{"location":"operator-manual/pr-mr-workflow/#generate-a-private-key","title":"Generate a private key","text":"<p>You need a private key for your GitHub app to configure Burrito.</p> <ul> <li> <p>Follow the instructions in the GitHub documentation for generating private keys for GitHub Apps</p> </li> <li> <p>Save the private key file to your local machine. GitHub only stores the public portion of the key.</p> </li> </ul>"},{"location":"operator-manual/pr-mr-workflow/#configure-burrito","title":"Configure Burrito","text":"<p>Add the following environment variables to your Burrito controller deployment:</p> <ul> <li><code>BURRITO_CONTROLLER_GITHUBCONFIG_APPID</code>: The App ID of your GitHub app.</li> <li><code>BURRITO_CONTROLLER_GITHUBCONFIG_INSTALLATIONID</code>: The Installation ID of your GitHub app.</li> <li><code>BURRITO_CONTROLLER_GITHUBCONFIG_PRIVATEKEY</code>: The private key of your GitHub app.</li> </ul> <p>For example:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: burrito-github-config\n  namespace: burrito\ntype: Opaque\nstringData:\n  BURRITO_CONTROLLER_GITHUBCONFIG_APPID: \"123456\"\n  BURRITO_CONTROLLER_GITHUBCONFIG_INSTALLATIONID: \"12345678\"\n  BURRITO_CONTROLLER_GITHUBCONFIG_PRIVATEKEY: |\n    -----BEGIN RSA PRIVATE KEY-----\n    ...\n    -----END RSA PRIVATE KEY-----\n</code></pre>"},{"location":"operator-manual/pr-mr-workflow/#github-with-a-personal-access-token","title":"GitHub with a personal access token","text":""},{"location":"operator-manual/pr-mr-workflow/#generate-a-personal-access-token","title":"Generate a personal access token","text":"<p>You need a personal access token to configure Burrito. You can generate a personal access token in your GitHub account.</p> <p>Follow the instructions in the GitHub documentation for creating a personal access token:</p> <ul> <li>It should be a fine-grained token.</li> <li>Permissions: Configure the following Repository Permissions.</li> <li>Metadata: Select Read-only.</li> <li>Pull requests: Select Read &amp; write. This is required to issue comments on pull requests.</li> <li>Under Repository access, select which repositories you want the token to access.</li> </ul>"},{"location":"operator-manual/pr-mr-workflow/#configure-burrito_1","title":"Configure Burrito","text":"<p>Add the following environment variables to your Burrito controller deployment:</p> <ul> <li><code>BURRITO_CONTROLLER_GITHUBCONFIG_APITOKEN</code>: The personal access token of your GitHub app.</li> </ul> <p>For example:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: burrito-github-config\n  namespace: burrito\ntype: Opaque\nstringData:\n  BURRITO_CONTROLLER_GITHUBCONFIG_APITOKEN: github_pat_123456\n</code></pre>"},{"location":"operator-manual/pr-mr-workflow/#gitlab","title":"GitLab","text":""},{"location":"operator-manual/pr-mr-workflow/#generate-a-private-token","title":"Generate a private token","text":"<p>You need a private token for your GitLab app to configure Burrito. You can generate a private token in your GitLab account. Follow the instructions in the GitLab documentation for generating a private token.</p>"},{"location":"operator-manual/pr-mr-workflow/#configure-burrito_2","title":"Configure Burrito","text":"<p>Add the following environment variables to your Burrito controller deployment:</p> <ul> <li><code>BURRITO_CONTROLLER_GITLABCONFIG_APITOKEN</code>: The private token of your GitLab app.</li> <li><code>BURRITO_CONTROLLER_GITLABCONFIG_URL</code>: The URL of your GitLab instance.</li> </ul> <p>For example:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: burrito-gitlab-config\n  namespace: burrito\ntype: Opaque\nstringData:\n  BURRITO_CONTROLLER_GITLABCONFIG_APITOKEN: \"123456\"\n  BURRITO_CONTROLLER_GITLABCONFIG_URL: \"https://gitlab.example.com\"\n</code></pre> Environment variable Description <code>BURRITO_CONTROLLER_GITHUBCONFIG_APPID</code> the GtiHub App ID to send comment to GitHub's API <code>BURRITO_CONTROLLER_GITHUBCONFIG_INSTALLATIONID</code> the GitHub Installation ID to send comment to GitHub's API <code>BURRITO_CONTROLLER_GITHUBCONFIG_PRIVATEKEY</code> the GitHub App private key to send comment to GitHub's API <code>BURRITO_CONTROLLER_GITHUBCONFIG_APITOKEN</code> the API token to send comment to GitHub's API <code>BURRITO_CONTROLLER_GITLABCONFIG_APITOKEN</code> the API token to send comment to GitLab's API <code>BURRITO_CONTROLLER_GITLABCONFIG_URL</code> the URL of the GitLab instance"},{"location":"operator-manual/install/with-helm/","title":"Install burrito with Helm","text":""},{"location":"operator-manual/install/with-helm/#requirements","title":"Requirements","text":"<ul> <li>Installed kubectl command-line tool</li> <li>Installed helm command-line tool (version v3.8.0 and further)</li> <li>Have a kubeconfig file (default location is <code>~/.kube/config</code>)</li> </ul>"},{"location":"operator-manual/install/with-helm/#1-install-burrito","title":"1. Install burrito","text":"<p>Info</p> <p>Our Helm chart is published in an OCI-based registry (ghcr.io). You must use Helm v3.8.0 or above.</p> <pre><code>helm install burrito oci://ghcr.io/padok-team/charts/burrito -n burrito-system --create-namespace\n</code></pre> <p>This will create a new namespace, <code>burrito-system</code>, where the burrito operator will live.</p> <p>You can change the chart's version with any version available on our Chart registry.</p>"},{"location":"operator-manual/install/with-helm/#2-override-values","title":"2. Override values","text":"<p>You can inspect the chart's values with Helm.</p> <pre><code>helm show values oci://ghcr.io/padok-team/charts/burrito\n</code></pre> <p>The chart's source code is available on burrito GitHub repository.</p> <p>Here is an example of values file overriding some default values of burrito:</p> <pre><code># Example of external Redis instance\nredis:\n  enabled: false\nconfig:\n  burrito:\n    redis:\n      hostname: \"custom-redis.svc.cluster.local\"\n\ntenants:\n  # Example tenant with 1 service account having additional role bindings\n  - namespace:\n      create: true\n      name: \"burrito-project-1\"\n      labels: {}\n      annotations: {}\n    serviceAccounts:\n      - name: runner-project-1\n        additionalRoleBindings:\n          - name: custom\n            role:\n              kind: ClusterRole\n              name: custom-role\n        annotations: {}\n        labels: {}\n  # Example tenant with multiple service accounts using GKE Workload Identity\n  - namespace:\n      create: true\n      name: \"burrito-project-1\"\n    serviceAccounts:\n      - name: runner-frontend\n        annotations:\n          iam.gke.io/gcp-service-account: burrito-frontend@company-project.iam.gserviceaccount.com\n      - name: runner-backend\n        annotations:\n          iam.gke.io/gcp-service-account: burrito-backend@company-project.iam.gserviceaccount.com\n      - name: runner-network\n        annotations:\n          iam.gke.io/gcp-service-account: burrito-network@company-project.iam.gserviceaccount.com\n</code></pre> <p>Info</p> <p>Learn more about these values in Advanced Configuration and Multi-tenant architecture.</p>"},{"location":"operator-manual/install/with-static-manifests/","title":"Install burrito with static manifests","text":""},{"location":"operator-manual/install/with-static-manifests/#requirements","title":"Requirements","text":"<ul> <li>Installed kubectl command-line tool.</li> <li>Have a kubeconfig file (default location is <code>~/.kube/config</code>).</li> </ul>"},{"location":"operator-manual/install/with-static-manifests/#install-burrito","title":"Install burrito","text":"<p>Info</p> <p>This will install a mono-tenant version of burrito. See the Helm installation method for a multi-tenant-architecture.</p> <pre><code>kubectl create namespace burrito\nkubectl apply -n burrito -f https://raw.githubusercontent.com/padok-team/burrito/main/manifests/install.yaml\n</code></pre> <p>This will create a new namespace, <code>burrito</code>, where burrito services will live.</p> <p>Warning</p> <p>The installation manifests include <code>ClusterRoleBinding</code> resources that reference <code>burrito</code> namespace. If you are installing burrito into a different namespace then make sure to update the namespace reference.</p>"},{"location":"user-guide/","title":"Overview","text":"<p>This guide is for developers who have burrito installed for them and are managing layers.</p> <p>Note</p> <p>Please make sure you've completed the getting started guide.</p>"},{"location":"user-guide/additionnal-trigger-path/","title":"Additionnal Trigger Paths","text":"<p>By default, when you creating a layer, you must specify a repository and a path. This path is used to trigger the layer changes which means that when a change occurs in this path, the layer will be plan / apply accordingly.</p> <p>Sometimes, you need to trigger changes on a layer where the changes are not in the same path (e.g. update made on an internal terraform module hosted on the same repository).</p> <p>That's where the additional trigger paths feature comes!</p> <p>Let's take the following <code>TerraformLayer</code>:</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\n  name: random-pets-terragrunt\nspec:\n  terraform:\n    version: \"1.3.1\"\n    terragrunt:\n      enabled: true\n      version: \"0.45.4\"\n  remediationStrategy:\n    autoApply: true\n  path: \"terragrunt/random-pets/test\"\n  branch: \"main\"\n  repository:\n    name: burrito\n    namespace: burrito\n</code></pre> <p>The repository's path of my <code>TerraformLayer</code> is set to <code>terragrunt/random-pets/test</code>. But I want to trigger the layer plan / apply when a change occurs on my module which is in the <code>modules/random-pets</code> directory of my repository.</p> <p>To do so, I just have to add the <code>config.terraform.padok.cloud/additionnal-trigger-paths</code> annotation to my <code>TerraformLayer</code> as follow:</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\n  name: random-pets-terragrunt\n  annotations:\n    config.terraform.padok.cloud/additionnal-trigger-paths: \"modules/random-pets\"\nspec:\n  terraform:\n    version: \"1.3.1\"\n    terragrunt:\n      enabled: true\n      version: \"0.45.4\"\n  remediationStrategy:\n    autoApply: true\n  path: \"terragrunt/random-pets/test\"\n  branch: \"main\"\n  repository:\n    name: burrito\n    namespace: burrito\n</code></pre> <p>Now, when a change occurs in the <code>modules/random-pets</code> directory, the layer will be plan / apply.</p>"},{"location":"user-guide/override-runner/","title":"Override the runner pod spec","text":"<p>Both <code>TerraformRepository</code> and <code>TerraformLayer</code> expose a <code>spec.overrideRunnerSpec</code> map field.</p> <p>If the field is specified for a given <code>TerraformRepository</code> it will be applied by default to all <code>TerraformLayer</code> linked to it.</p> <p>If the field is specified for a given <code>TerraformLayer</code> it will take precedence over the <code>TerraformRepository</code> configuration.</p> <p>Available overrides are:</p> Fields <code>ImagePullSecrets</code> <code>Image</code> <code>Tolerations</code> <code>NodeSelector</code> <code>ServiceAccountName</code> <code>Resources</code> <code>Env</code> <code>EnvFrom</code> <code>Volumes</code> <code>VolumeMounts</code> <code>Metadata.Annotations</code> <code>Metadata.Labels</code> <p>For instance with the following configuration, all the runner pods will have the specifications described inside the <code>TerraformRepository</code>:</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformRepository\nmetadata:\n  name: burrito\n  namespace: burrito\nspec:\n  repository:\n    url: https://github.com/padok-team/burrito\n  overrideRunnerSpec:\n    imagePullSecrets:\n    - name: ghcr-creds\n    tolerations:\n    - effect: NoSchedule\n      key: burrito.io/production\n      operator: Exists\n    nodeSelector:\n      production: \"true\"\n    serviceAccountName: \"production\"\n---\napiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\n  name: random-pets\n  namespace: burrito\nspec:\n  terraform:\n    version: \"1.3.1\"\n  path: \"internal/e2e/testdata/random-pets\"\n  branch: \"main\"\n  repository:\n    name: burrito\n    namespace: burrito\n</code></pre> <p>In the following case, <code>tolerations</code> and <code>nodeSelector</code> will be merged:</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformRepository\nmetadata:\n  name: burrito\n  namespace: burrito\nspec:\n  repository:\n    url: https://github.com/padok-team/burrito\n  overridePodSpec:\n    imagePullSecrets:\n    - name: ghcr-creds\n    tolerations:\n    - effect: NoExecute\n      key: burrito.io/production\n      operator: Exists\n    nodeSelector:\n      production: \"true\"\n    serviceAccountName: \"production\"\n---\napiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\n  name: random-pets\n  namespace: burrito\nspec:\n  terraform:\n    version: \"1.3.1\"\n  path: \"internal/e2e/testdata/random-pets\"\n  branch: \"main\"\n  repository:\n    name: burrito\n    namespace: burrito\n  overrideRunnerSpec:\n    tolerations:\n    - effect: NoSchedule\n      key: burrito.io/production\n      operator: Exists\n    nodeSelector: {}\n</code></pre> <p>Resulting in the following <code>podSpec</code>:</p> <pre><code>tolerations:\n- effect: NoSchedule\n  key: burrito.io/production\n  operator: Exists\nnodeSelector:\n  production: \"true\"\n</code></pre>"},{"location":"user-guide/private-modules/","title":"Configure the TerraformLayer to use private modules' repositories","text":"<p>If your stack use Terraform modules that are hosted on private repositories, you can configure the <code>TerraformLayer</code> to be able to use those private modules by configuring the <code>overrideRunnerSpec</code> in your resource definition.</p>"},{"location":"user-guide/private-modules/#the-layer-uses-a-private-module-with-https","title":"The layer uses a private module with HTTPS","text":""},{"location":"user-guide/private-modules/#1-create-a-secret-containing-a-git-credentilas-file","title":"1. Create a secret containing a .git-credentilas file","text":"<p>Create a Kubernetes Secret which looks like the following:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: git-credentials\nstringData:\n  .git-credentials: |\n    https://&lt;username&gt;:&lt;password | access_token&gt;@github.com\n</code></pre> <p>Info</p> <p>You can replace <code>github.com</code> with <code>gitlab.com</code> or any GitHub or GitLab URL.</p>"},{"location":"user-guide/private-modules/#2-create-a-configmap-for-configuring-the-git-agent","title":"2. Create a ConfigMap for configuring the git agent","text":"<p>Create a Kubernetes ConfigMap which looks like the following:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: gitconfig\ndata:\n  .gitconfig: |\n    [credential]\n        helper = store\n</code></pre>"},{"location":"user-guide/private-modules/#3-mount-those-configurations-files-in-the-runners-configuration","title":"3. Mount those configurations' files in the runners' configuration","text":"<p>You need to mount this Secret and ConfigMap as file with some VolumeMounts:</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\n  name: terragrunt-private-module\nspec:\n  terraform:\n    version: \"1.3.1\"\n    terragrunt:\n      enabled: true\n      version: \"0.45.4\"\n  remediationStrategy:\n    autoApply: true\n  path: \"terragrunt/random-pets-private-module/test\"\n  branch: main\n  repository:\n    name: burrito\n    namespace: burrito\n  overrideRunnerSpec:\n    env:\n    volumes:\n    - name: gitconfig\n      configMap:\n        name: gitconfig\n    - name: git-credentials\n      secret:\n        secretName: git-credentials\n    volumeMounts:\n    - name: gitconfig\n      mountPath: /home/burrito/.gitconfig\n      subPath: .gitconfig\n    - name: git-credentials\n      mountPath: /home/burrito/.git-credentials\n      subPath: .git-credentials\n</code></pre>"},{"location":"user-guide/private-modules/#the-layer-uses-a-private-module-with-ssh","title":"The layer uses a private module with SSH","text":""},{"location":"user-guide/private-modules/#1-create-a-secret-with-a-ssh-private-key-which-can-pull-the-modules-repositories","title":"1. Create a Secret with a SSH private key which can pull the modules' repositories","text":"<p>Create a Kubernetes Secret which looks like the following:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: git-private-key\u2013modules\n  namespace: burrito\ntype: Opaque\nstringSata:\n  key: |\n    -----BEGIN OPENSSH PRIVATE KEY-----\n    ...\n    -----END OPENSSH PRIVATE KEY-----\n</code></pre> <p>Info</p> <p>You can update the Kubernetes ConfigmMap <code>burrito-ssh-known-hosts</code> to add others known hosts.</p>"},{"location":"user-guide/private-modules/#2-mount-this-secret-in-your-runner-spec","title":"2. Mount this Secret in your runner spec","text":"<p>You need to mount this Secret as a volume and add a <code>GIT_SSH_COMMAND</code> environements variables:</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\n  name: terragrunt-private-module-ssh\nspec:\n  terraform:\n    version: \"1.3.1\"\n    terragrunt:\n      enabled: true\n      version: \"0.45.4\"\n  remediationStrategy:\n    autoApply: true\n  path: \"terragrunt/random-pets-private-module-ssh/test\"\n  branch: main\n  repository:\n    name: burrito\n    namespace: burrito\n  overrideRunnerSpec:\n    env:\n    - name: GIT_SSH_COMMAND\n      value: ssh -i /home/burrito/.ssh/key\n    volumes:\n    - name: private-key\n      secret:\n        secretName: private-key-ssh-module\n    volumeMounts:\n    - name: private-key\n      mountPath: /home/burrito/.ssh/key\n      subPath: key\n      readOnly: true\n</code></pre> <p>As you can see, we added a new <code>overrideRunnerSpec</code> field to the <code>TerraformLayer</code> spec. This field allows you to override the default runner pod spec. In this case, we added a new volume and a new environment variable to the runner pod spec:</p> <ul> <li>The volume is a secret volume that contains the SSH key we created earlier</li> <li>The environment variable is used to tell git to use the SSH key we added to the runner pod</li> </ul>"},{"location":"user-guide/remediation-strategy/","title":"Choose a remediation strategy","text":"<p>The remediation strategy is the way to tell Burrito how it should handle the remediation of drifts on your Terraform layers.</p> <p>As for the runner spec override, you can specify a <code>spec.remediationStrategy</code> either on the <code>TerraformRepository</code> or the <code>TerraformLayer</code>.</p> <p>The configuration of the <code>TerraformLayer</code> will take precedence.</p>"},{"location":"user-guide/remediation-strategy/#specremediationstrategy-api-reference","title":"<code>spec.remediationStrategy</code> API reference","text":"Field Type Default Effect <code>autoApply</code> Boolean <code>false</code> If <code>true</code> when a <code>plan</code> shows drift, it will run an <code>apply</code>. <code>onError.maxRetries</code> Integer <code>5</code> or value defined in Burrito configuration How many times Burrito should retry a <code>plan</code>/<code>apply</code> when a runner fails. <p>Warning</p> <p>This operator is still experimental. Use <code>spec.remediationStrategy.autoApply: true</code> at your own risk.</p>"},{"location":"user-guide/remediation-strategy/#example","title":"Example","text":"<p>With this example configuration, Burrito will create <code>apply</code> runs for this layer, with a maximum of 3 retries.</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\n  name: random-pets-terragrunt\nspec:\n  remediationStrategy:\n    autoApply: true\n    onError:\n      maxRetries: 3\n  # ... snipped ...\n</code></pre>"},{"location":"user-guide/terraform-version/","title":"Choose a terraform/terragrunt version","text":""},{"location":"user-guide/terraform-version/#choose-terraform-version","title":"Choose terraform version","text":"<p>Both <code>TerraformRepository</code> and <code>TerraformLayer</code> expose a <code>spec.terrafrom.version</code> map field.</p> <p>If the field is specified for a given <code>TerraformRepository</code> it will be applied by default to all <code>TerraformLayer</code> linked to it.</p> <p>If the field is specified for a given <code>TerraformLayer</code> it will take precedence over the <code>TerraformRepository</code> configuration.</p>"},{"location":"user-guide/terraform-version/#enable-terragrunt","title":"Enable Terragrunt","text":"<p>You can specify usage of terragrunt as follow:</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\n  name: random-pets-terragrunt\nspec:\n  terraform:\n    version: \"1.3.1\"\n    terragrunt:\n      enabled: true\n      version: \"0.44.5\"\n  remediationStrategy:\n    autoApply: false\n  path: \"internal/e2e/testdata/terragrunt/random-pets/prod\"\n  branch: \"feat/handle-terragrunt\"\n  repository:\n    name: burrito\n    namespace: burrito\n</code></pre> <p>Info</p> <p>This configuration can be specified at the <code>TerraformRepository</code> level to be enabled by default in each of its layers.</p>"}]}